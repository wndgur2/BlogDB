---
category: Algorithm
title: 레이저 통신
site: Baekjoon
date_started: 2023.06.24
tags: cpp, DFS, shortest-path
level: G3
---

# [문제](https://www.acmicpc.net/problem/6087)

기차에서 하느라 목소리 좋은 규빈이가 대신 읽어주어 감사하다~

# 문제 풀이
각 칸까지 도달하기 위한 최소 거울 수를 2차원 벡터(`map_mirror`)에 저장하면서 DFS를 수행했습니다.  
최소 거울 수가 최소 이동거리를 보장하기 때문에 별도로 최소 이동거리 검증은 하지 않았습니다.  

DFS에서는 각 칸에서 꺾는지 여부를 확인해야 하므로 매개변수로 방향(`direction`)을 전달했습니다.  

코드를 간결하게 하기 위해:  
- `d_loc`: 크기가 1인 4방향 벡터를 저장  
- `move(int direction, vector<int> loc)`: 현재 좌표에서 direction으로 이동한 좌표를 리턴  
- `check_no_wall(vector<int> loc)`: 해당 좌표가 유효한지 확인  

중간에 디버깅 출력을 위해 DFS 과정을 출력하는 코드가 있습니다. (line 35)

# 코드
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

vector<vector<int>> d_loc{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; // dy, dx
vector<vector<char>> map_; // 각 칸의 character
vector<vector<int>> map_mirror; // 각 칸까지 가기 위한 최소 거울 수
int w, h, i, j;

vector<int> move(int direction, vector<int> loc){
  vector<int> new_loc = loc;
  new_loc[0] += d_loc[direction][0];
  new_loc[1] += d_loc[direction][1];
  return new_loc;
}

bool check_no_wall(vector<int> loc){
  if((loc[0] < 0) || (loc[1] < 0)) return false;
  if((loc[0] >= h) || (loc[1] >= w)) return false;
  if(map_[loc[0]][loc[1]] == '*') return false;
  return true;
}

void dfs(int direction, vector<int> loc){
  vector<int> new_loc;
  int new_direction, is_turned;
  for(int d=0; d<4; d++){
    new_direction = (direction+d) % 4;
    new_loc = move(new_direction, loc);
    is_turned = (d==0 ? 0 : 1);
    if(check_no_wall(new_loc)){
      if(map_mirror[loc[0]][loc[1]] < map_mirror[new_loc[0]][new_loc[1]]){
        map_mirror[new_loc[0]][new_loc[1]] = map_mirror[loc[0]][loc[1]] + is_turned;
        dfs(new_direction, new_loc);
      }
    }
  }
}

int main(){
  cin >> w >> h;
  for(i=0; i<h; i++){
    vector<char> tmp;
    vector<int> tmp_;
    map_.push_back(tmp);
    map_mirror.push_back(tmp_);
    for(j=0; j<w; j++){
      map_[i].push_back(' ');
      map_mirror[i].push_back(h*w);
    }
  }
  int start_x, start_y, end_x, end_y;
  bool found_C = false;
  for(i=0; i<h; i++){
    for(j=0; j<w; j++){
      cin >> map_[i][j];
      if(map_[i][j] == 'C'){
        if(found_C){
          end_y = i; end_x = j;
        } else{
          start_y = i; start_x = j;
          found_C = true;
        }
      }
    }
  }
  map_[start_y][start_x] = '.';
  map_mirror[start_y][start_x] = 0;
  for(i=0; i<4; i++)
    dfs(i, {start_y, start_x});
  cout << map_mirror[end_y][end_x] << endl;
  return 0;
}
```