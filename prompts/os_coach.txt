

Chapter 1 Introduction

1.1 What Operating Systems Do 

1.2 Computer-System Organization 

1.3 Computer-System Architecture 

1.4 Operating-System Operations 

1.5 Resource Management 

1.6 Security and Protection 

1.7 Virtualization 

1.8 Distributed Systems 

1.9 Kernel Data Structures 

1.10 Computing Environments 

1.11 Free and Open-Source Operating Systems 

1.12 Summary 

Chapter 2 Operating-System Structures

2.1 Operating-System Services 

2.2 User and Operating-System Interface 

2.3 System Calls 

2.4 System Services 

2.5 Linkers and Loaders 

2.6 Why Applications Are Operating-System Specific 

2.7 Operating-System Design and Implementation 

2.8 Operating-System Structure 

2.9 Building and Booting an Operating System 

2.10 Operating-System Debugging 

2.11 Summary 

Part Two Process Management

Chapter 3 Processes

3.1 Process Concept 

3.2 Process Scheduling 

3.3 Operations on Processes 

3.4 Interprocess Communication 

3.5 IPC in Shared-Memory Systems 

3.6 IPC in Message-Passing Systems 

3.7 Examples of IPC Systems 

3.8 Communication in Client–Server Systems 

3.9 Summary 

Chapter 4 Threads & Concurrency

4.1 Overview 

4.2 Multicore Programming 

4.3 Multithreading Models 

4.4 Thread Libraries 

4.5 Implicit Threading 

4.6 Threading Issues 

4.7 Operating-System Examples 

4.8 Summary 

Chapter 5 CPU Scheduling

5.1 Basic Concepts 

5.2 Scheduling Criteria 

5.3 Scheduling Algorithms 

5.4 Thread Scheduling 

5.5 Multi-Processor Scheduling 

5.6 Real-Time CPU Scheduling 

5.7 Operating-System Examples 

5.8 Algorithm Evaluation 

5.9 Summary 

Part Three Process Synchronization

Chapter 6 Synchronization Tools

6.1 Background 

6.2 The Critical-Section Problem 

6.3 Peterson’s Solution 

6.4 Hardware Support for Synchronization 

6.5 Mutex Locks 

6.6 Semaphores 

6.7 Monitors 

6.8 Liveness 

6.9 Evaluation 

6.10 Summary 

Chapter 7 Synchronization Examples

7.1 Classic Problems of Synchronization 

7.2 Synchronization within the Kernel 

7.3 POSIX Synchronization 

7.4 Synchronization in Java 

7.5 Alternative Approaches 

7.6 Summary 

Chapter 8 Deadlocks

8.1 System Model 

8.2 Deadlock in Multithreaded Applications 

8.3 Deadlock Characterization 

8.4 Methods for Handling Deadlocks 

8.5 Deadlock Prevention 

8.6 Deadlock Avoidance 

8.7 Deadlock Detection 

8.8 Recovery from Deadlock 

8.9 Summary 

Part Four Memory Management

Chapter 9 Main Memory

9.1 Background 

9.2 Contiguous Memory Allocation 

9.3 Paging 

9.4 Structure of the Page Table 

9.5 Swapping 

9.6 Example: Intel 32- and 64-bit Architectures 

9.7 Example: ARMv8 Architecture 

9.8 Summary 

Chapter 10 Virtual Memory

10.1 Background 

10.2 Demand Paging 

10.3 Copy-on-Write 

10.4 Page Replacement 

10.5 Allocation of Frames 

10.6 Thrashing 

10.7 Memory Compression 

10.8 Allocating Kernel Memory 

10.9 Other Considerations 

10.10 Operating-System Examples 

10.11 Summary 

Part Five Storage Management

Chapter 11 Mass-Storage Structure

11.1 Overview of Mass-Storage Structure 

11.2 HDD Scheduling 

11.3 NVM Scheduling 

11.4 Error Detection and Correction 

11.5 Storage Device Management 

11.6 Swap-Space Management 

11.7 Storage Attachment 

11.8 RAID Structure 

11.9 Summary 

Chapter 12 I/O Systems

12.1 Overview 

12.2 I/O Hardware 

12.3 Application I/O Interface 

12.4 Kernel I/O Subsystem 

12.5 Transforming I/O Requests to Hardware Operations 

12.6 STREAMS 

12.7 Performance 

12.8 Summary 

Part Six File System

Chapter 13 File-System Interface

13.1 File Concept 

13.2 Access Methods 

13.3 Directory Structure 

13.4 Protection 

13.5 Memory-Mapped Files 

13.6 Summary 

Chapter 14 File-System Implementation

14.1 File-System Structure 

14.2 File-System Operations 

14.3 Directory Implementation 

14.4 Allocation Methods 

14.5 Free-Space Management 

14.6 Efficiency and Performance 

14.7 Recovery 

14.8 Example: The WAFL File System 

14.9 Summary 

Chapter 15 File-System Internals

15.1 File Systems 

15.2 File-System Mounting 

15.3 Partitions and Mounting 

15.4 File Sharing 

15.5 Virtual File Systems 

15.6 Remote File Systems 

15.7 Consistency Semantics 

15.8 NFS 

15.9 Summary 

Part Seven Security and Protection

Chapter 16 Security

16.1 The Security Problem 

16.2 Program Threats 

16.3 System and Network Threats 

16.4 Cryptography as a Security Tool 

16.5 User Authentication 

16.6 Implementing Security Defenses 

16.7 An Example: Windows 10 

16.8 Summary 

Chapter 17 Protection

17.1 Goals of Protection 

17.2 Principles of Protection 

17.3 Protection Rings 

17.4 Domain of Protection 

17.5 Access Matrix 

17.6 Implementation of the Access Matrix 

17.7 Revocation of Access Rights 

17.8 Role-Based Access Control 

17.9 Mandatory Access Control (MAC) 

17.10 Capability-Based Systems 

17.11 Other Protection Improvement Methods 

17.12 Language-Based Protection 

17.13 Summary 

Part Eight Advanced Topics

Chapter 18 Virtual Machines

18.1 Overview 

18.2 History 

18.3 Benefits and Features 

18.4 Building Blocks 

18.5 Types of VMs and Their Implementations 

18.6 Virtualization and Operating-System Components 

18.7 Examples 

18.8 Virtualization Research 

18.9 Summary 

Chapter 19 Networks and Distributed Systems

19.1 Advantages of Distributed Systems 

19.2 Network Structure 

19.3 Communication Structure 

19.4 Network and Distributed Operating Systems 

19.5 Design Issues in Distributed Systems 

19.6 Distributed File Systems 

19.7 DFS Naming and Transparency 

19.8 Remote File Access 

19.9 Final Thoughts on Distributed File Systems 

19.10 Summary 